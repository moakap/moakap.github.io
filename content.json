{"pages":[],"posts":[{"title":"Moakap's blog","text":"","link":"/2021/05/27/about/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/05/27/hello-world/"},{"title":"The 1st blog.","text":"This is the 1st post of the blog.","link":"/2021/05/27/the-1st-post/"},{"title":"Expo中的Assets资源使用","text":"图片、字体、视频、音频和其它你的App里用到的不是JavaScript的文件都被认为是资源(asset). 就比如说在在互联网上， 所有你通过http传输获取的东西叫资源。这一点跟移动app不同，在app里资源一般跟app本身的二进制文件打包在一起。 然而，在Expo中通过require引用的资源（例如&lt;Image source={require('./assets/images/example.png')} /&gt;在编译的时候已经在本地文件系统存在了）跟在web中通过URL引用的资源（例如&lt;Image source={{uri: 'http://yourwebsite.com/logo.png'}} /&gt;）是有区别的。Expo不保证通过web URL引用的这些资源的可用性，因为这些资源不在Expo的管理范围。另外，Expo本身无法获取任意Web URL的全部信息。当你的资源存在于本地文件系统的时候，打包器能够读取资源的基本元数据metadata，比如宽度、高度，然后将这些信息传递给你的App，所以你不需要明确指明某个图片的宽度和高度。然而当你使用远程web URL引用资源的时候，你就必须明确得指明宽度、高度这些信息，否则系统会默认使用0x0。 最后，我们也会看到两者的缓存机制也不同。 接下来是对require类型资源得详细解释，这些资源必须在编译的时候就已经在文件系统存在。而在通过远程URL引用图片资源的例子中，系统默认你知道怎么将一个图片上传到网络，并确保能够被web和移动App访问。 资源的位置开发环境当你工作在项目的本地开发环境时，所有资源被存放在本地文件系统，并且集成到JavaScript的模块中。所以如果想要包含某个图片，你可以直接在javascript中使用require引用，像这样require('./assets/images/example.png')。这里唯一的不同是，你必须指定资源的文件后缀；没有后缀的话，系统会默认这是一个javascript文件。下边这个语句会在编译的时候把资源连同资源的元数据一起赋值给一个对象，然后整个对象传递给Image组件做渲染。 &lt;Image source={require('./assets/images/example.png')} /&gt; 生产环境每次你通过Expo发布App的时候，Expo都会把所有需要的资源上传到Amazon CloudFront，一个快速的CDN。而且整个上传过程会非常智能，没有变化的资源会被跳过。整个过程都由Expo自动完成，不需要开发者任何操作。 自定义支持的资源扩展有时候你需要用到的文件类型不在Expo默认的支持范围。例如，如果你想要在App中导入数据库，就可能会用到.db文件。参考自定义Metro了解如何通过Metro自定义iOS和Android资源扩展，参考自定义Webpack了解如何通过Webpack自定义Web资源扩展。 优化图片图片一般是Expo项目中占用空间最多的资源。优化图片可以减少用户设备上的空间占用，从而降低显示前的加载时间和使用带宽。可以通过执行npx expo-optimize命令来压缩PNG和JPEG图片。也可以设置下边的选项： --save: 备份所有图片（以.orig文件的形式保存） --quality=N: 设置文件压缩比率，N可以是1-100之间的整数（包含1和100，默认为60） --include=\"[pattern]\": 设置仅优化满足通配符模式的资源（默认使用app.json中的assetBundlePatterns字段） --exclude=\"[pattern]\": 排除满足通配符模式的资源 注意：所有通配符得匹配范围都是相对于项目的根目录，跟执行命令所在的目录无关。 字体字体是启动App必不可缺的资源。web应用中的字体加载问题分为FOUT (Flash of Unstyled Text), FOIT (Flash of Invisible Text), FOFT (Flash of Faux Text)这几种，详细可以参考这里。 icon-font-powered的默认行为是第一次加载的时候使用FOIT，然后在后续的加载中字体会自动被缓存。相比较于传统Web，在用户对移动设备有更高的标准要求，所以你可能需要在初始屏幕加载的过程中预加载和缓存字体和一些重要的图片。 缓存参考[这里](Asset Caching - Expo Documentation)了解更多资源缓存的话题。","link":"/2021/05/27/Expo/Assets-in-Expo/"},{"title":"React中的Context","text":"Context定义和目的Context 提供了一种在组件之间共享数据的方式，而不必显式地通过组件树的逐层传递 props。 应用场景哪些数据会需要共享？ Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。 使用步骤1. 创建并初始化Context1const MyContext = createContex(defaultValue); 创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。 2. 订阅Context1&lt;MyContext.Provider value={/* 某个值 */}&gt; Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。 这里有两个相关的概念 Provider - Context提供者，或Context的订阅者。可以理解为通过Provider为其内部组件订阅了Context值的变动，一旦Context值有变化，就会触发内部组件重新渲染。 Comsumer - Context消费者（消费组件），或者叫Context使用者。即在Provider内部使用useContext()来使用或消费Context的组件。这些组件通过useContext()获取、使用Context的最新值。 3. 使用Conext3.1 React组件中使用1const value = useContext(MyContext); 在消费组件中引用Context。value会从组件树中离自身最近的那个匹配的Provider中读取到当前的Context值。 3.2 纯函数式组件中使用在纯函数式的组件中，可以使用Consumer来引用context的值。如果没有上层对应的Provider，value等同于传递给createContext()的defaultValue. 123&lt;MyContext.Consumer&gt; {value =&gt; /* 基于 context 值进行渲染*/}&lt;/MyContext.Consumer&gt; 4. Context的更新4.1 自上而下更新Context自上而下更新指的是更新Provider的value值。当 Provider 的 value 值发生变化时，它内部的所有消费组件内通过useContext获取到的值会自动更新，并触发重新渲染。 1234567891011121314151617181920212223242526272829303132333435//App.js// ....export default function App() { //... // const {contextValue, setContextValue} = React.useState(initialValue); // function to update the context value function updateContext(newValue) { // ... // 更新contextValue, ConsumerComponent1, ConsumerComponent2, ConsumerComponent3, ConsumerComponent11都会触发重新渲染。 setContextValue(newValue) } ... return ( &lt;App&gt; &lt;MyContext.Provider value={contextValue}&gt; &lt;ConsumerComponent1&gt; &lt;ConsumerComponent11&gt; // .... &lt;/ComsumerComponent11&gt; &lt;/ConsumerComponent1&gt; &lt;ConsumerComponent2 /&gt; &lt;ConsumerComponent3 /&gt; &lt;/MyContext.Provider&gt; &lt;/App&gt; ); } 4.2 自下而上（从消费组件）更新Context在某些情况下，需要在某个消费组件内更新context，并且适配到整个程序。比如通过应用程序的setting组件修改UI风格。 这时就需要通过回调将更新一层层传递到对应的Provider，更新Provide对应的value，从而触发所有相关消费组件的更新。 1234567891011121314151617181920212223242526272829// app.jsexport default function App() { ... const {contextValue, setContextValue} = React.useState(initialValue); // function to update the context value function updateContext(newValue) { // ... // 更新contextValue, ConsumerComponent1, ConsumerComponent2, ConsumerComponent3, ConsumerComponent11都会触发重新渲染。 setContextValue(newValue) } ... return ( &lt;App&gt; &lt;MyContext.Provider value={contextValue}&gt; &lt;ConsumerComponent1&gt; &lt;ConsumerComponent11 updateValue={updateContext}&gt; // 通过回调形式的props, 在ConsumerComponent11中更新contextValue, 因为contextValue属于最顶层的Provider的值，所以也会触发ConsumerComponent1, ConsumerComponent2, ConsumerComponent3重新渲染。 &lt;/ComsumerComponent11&gt; &lt;/ConsumerComponent1&gt; &lt;ConsumerComponent2 /&gt; &lt;ConsumerComponent3 /&gt; &lt;/MyContext.Provider&gt; &lt;/App&gt; );} 4.3 Provider嵌套在一些情况下，可能会出现同一个Context的provider嵌套的情况，这时候可以理解为两个Context。不同的是， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647...const {contextValue, setContextValue} = React.useState(initialValue);// function to update the context valuefunction updateContext(newValue) { // ... // 更新contextValue, ConsumerComponent1, ConsumerComponent2, ConsumerComponent3, ConsumerComponent11都会触发重新渲染。 setContextValue(newValue)}...return ( &lt;App&gt; &lt;MyContext.Provider value={contextValue}&gt; &lt;ConsumerComponent1&gt; &lt;ConsumerComponent11 /&gt; &lt;/ConsumerComponent1&gt; &lt;ConsumerComponent2&gt; ... // 如果只希望更新ComsumerComponent21, ComsumerComponent22中的值 const localContextValue = useContext(MyContext); // 从上一层Provider中获取当前值 const {tempContextValue, setTempContextValue} = React.useState(localContextValue); function updateTempContext(newValue) { // 这里更新以后只会触发ConsumerComponent21和ConsumerComponent22的重新渲染 setTempContextValue(newValue); } // 这里新建Provider，在ConsumerComponent21和ConsumerComponent22之间共享数据。 &lt;MyContext.Provider value={tempValue}&gt; &lt;ConsumerComponent21&gt; // 在ConsumerComponent21中通过useContext(MyContext)订阅 // 获取到的值为离自身最近的那个匹配的Provider中读取到的Context值,即tempValue &lt;/ConsumerComponent21&gt; &lt;ConsumerComponent22&gt; &lt;/ConsumerComponent22&gt; &lt;/MyContext.Provider value={contextValue}&gt; &lt;/ConsumerComponent2&gt; &lt;ConsumerComponent3 /&gt; &lt;/MyContext.Provider&gt; &lt;/App&gt;); 官方文档官方文档请参考下边的基础和高级教程。 Hook API 索引 – React (reactjs.org) Context – React (reactjs.org)","link":"/2021/05/27/React/Context-in-React/"},{"title":"Ubuntu下运行Swarm Bee节点","text":"1. 安装基本安装步骤比较简单，可以直接[Swarm Bee参考官方文档](Quick Start | Swarm Bee Client (ethswarm.org))。 1.1 Bee Clef安装在安装Bee之前，建议首先[安装Bee Clef软件包](Clef External Signer | Swarm Bee Client (ethswarm.org))。[Clef](go-ethereum/cmd/clef at master · ethereum/go-ethereum (github.com))是Go以太坊客户端使用的独立签名器（单独的一个对以太坊交易进行签名认证的服务），能够管理基于key-file的账户和硬钱包账户。[Bee-Clef](ethersphere/bee-clef: bee-clef is official ethereum clef binary wrapped and preconfigured for bee as a service (github.com))则在clef基础上针对bee做了定制化配置。Bee节点可以通过bee-clef来访问Swarm测试网或以太坊主网。当然，你也可以直接在本地运行原生的[clef](go-ethereum/cmd/clef at master · ethereum/go-ethereum (github.com))，然后增加自己的配置在运行Bee。如果确定要使用Bee-clef，必须在Bee之前先安装Bee Clef。 选择最新版本 打开[Bee-clef下载页面](Releases · ethersphere/bee-clef (github.com))，查看最新版本。写当前文档时的最新版本为v0.4.12。 安装Bee-Clef 下载Bee-clef 12wget https://github.com/ethersphere/bee-clef/releases/download/v0.4.12/bee-clef_0.4.12_arm64.debsudo dpkg -i bee-clef_0.4.12_arm64.deb 配置Bee-clef安装以后的默认配置文件在/etc/bee-clef目录下，包含4byte.json和rules.s两个文件，已经针对Bee做了基本配置，这里不需要特别修改。 123# ll /etc/bee-clef/-rw-r--r-- 1 root root 163 Feb 25 01:48 4byte.json-rw-r--r-- 1 root root 249 Feb 25 01:48 rules.js 启动Bee-Clef在使用后台启动之前，建议先通过手工启动查看bee-clef是否正确安装。正常启动后会有一下的日志打印，其中会出现三个文件路径 /etc/bee-clef/4byte.json 4byte数据库文件，包含了默认的Bee需要的一些方法。 /etc/bee-clef/rules.js 签名器规则文件，定义了最基本的签名规则。比如一般来说，我们的很多交易或操作需要用户手工确认才能进行。但是也有一些操作，可以在不提示用户的情况下直接允许，比如规则文件里提到的启动、列出账户等。 123456789101112131415function OnSignerStartup() { return \"Approve\"}function OnApprovedTx() { return \"Approve\"}function ApproveListing() { return \"Approve\"}function ApproveTx() { return \"Approve\"}function ApproveSignData() { return \"Approve\"} /var/lib/bee-clef/clef.ipc 这个是bee-clef签名器与Bee节点之间进行通信的IPC通信管道，bee的所有请求都是通过这个管道发送到bee-clef。在接下来Bee的配置文件中也会用到。 bee-clef正常启动后，一旦bee节点开始跟bee-clef交互，日志中每隔几秒或几分钟就会打印INFO [05-11|23:41:53.365] Op approved. 12345678910111213141516171819202122232425262728# bee-clef-service startbee-clef-service /var/lib/bee-clef /var/lib/bee-clef/password /etc/bee-clefWaiting for the clef.ipc file to show up at /var/lib/bee-clef/clef.ipcWARNING!Clef is an account management tool. It may, like any software, contain bugs.Please take care to- backup your keystore files,- verify that the keystore(s) can be opened with your password.Clef is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULARPURPOSE. See the GNU General Public License for more details.INFO [05-11|23:35:49.197] Using stdin/stdout as UI-channelINFO [05-11|23:35:49.925] Loaded 4byte database embeds=146841 locals=4 local=/etc/bee-clef/4byte.json{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"ui_onInputRequired\",\"params\":[{\"title\":\"Master Password\",\"prompt\":\"Please enter the password to decrypt the master seed\",\"isPassword\":true}]}Waiting for the clef.ipc file to show up at /var/lib/bee-clef/clef.ipcINFO [05-11|23:35:51.134] Rule engine configured file=/etc/bee-clef/rules.jsINFO [05-11|23:35:51.134] Starting signer chainid=5 keystore=/var/lib/bee-clef/keystore light-kdf=true advanced=falseINFO [05-11|23:35:51.135] IPC endpoint opened url=/var/lib/bee-clef/clef.ipc{\"jsonrpc\":\"2.0\",\"method\":\"ui_onSignerStartup\",\"params\":[{\"info\":{\"extapi_http\":\"n/a\",\"extapi_ipc\":\"/var/lib/bee-clef/clef.ipc\",\"extapi_version\":\"6.1.0\",\"intapi_version\":\"7.0.1\"}}]}INFO [05-11|23:36:12.193] Op approvedINFO [05-11|23:36:12.203] Op approvedINFO [05-11|23:41:53.365] Op approvedINFO [05-11|23:45:04.948] Op approvedINFO [05-11|23:45:08.734] Op approved Bee-Clef数据存储bee-clef的密钥及其它数据默认存储在/var/lib/bee-clef/. 1e4b791d7af0cf7a42a8/ - bee-clef账户保险库，里边的config.json文件中会保存加密过的key/value配置文件。 clef.ipc - 刚才提到的IPC通信管道。 keystore/ - bee-clef的账户地址。bee通过这个地址接入测试网或主网。 masterseed.json - 存放bee-clef密码 password账户的密钥文件 123456789# ll /var/lib/bee-clef/total 24drwxr-x--- 4 bee-clef bee-clef 4096 May 11 19:07 ./drwxr-xr-x 50 root root 4096 May 11 00:26 ../drwx------ 2 bee-clef bee-clef 4096 May 11 00:24 1e4b791d7af0cf7a42a8/srw-rw---- 1 root root 0 May 11 19:07 clef.ipc=drwx------ 2 bee-clef bee-clef 4096 May 11 00:24 keystore/-r-------- 1 bee-clef bee-clef 868 May 11 00:24 masterseed.json-rw------- 1 bee-clef bee-clef 32 May 11 00:24 password 1.2 Bee安装安装完bee-clef并确保其正常启动后，我们来安装Bee。 查看最新版本先到[Bee版本下载](Releases · ethersphere/bee (github.com))查看最新版本，当前最新版本为v0.5.3. 下载并安装Bee12wget https://github.com/ethersphere/bee/releases/download/v0.5.3/bee_0.5.3_amd64.debsudo dpkg -i bee_0.5.3_amd64.deb 配置Bee安装完毕以后默认配置文件在/etc/bee/bee.yaml。也可以运行bee printconfig &amp;&gt; bee-default.yaml打印当前的Bee配置作为模板来自己修改。其中几个地方需要注意。 clef配置 - 需要根据Bee-Clef的配置设置对应的IPC路径。 1234## enable clef signerclef-signer-enable: true## clef signer endpointclef-signer-endpoint: /var/lib/bee-clef/clef.ipc debug API地址 - 如果需要运行bee-dashboard，必须设置。默认为本机的1635端口，也可以自己修改。 1234## debug HTTP API listen address (default \":1635\")debug-api-addr: 127.0.0.1:1635## enable debug HTTP APIdebug-api-enable: true Swap节点 - 以太坊交换节点，也就是接入以太坊的入口节点。必须设置，默认为本机的:8545端口，如果你在本机运行geth （go的以太坊客户端）。否则，推荐使用Warm官方公共节点https://rpc.slock.it/goerli。也可以自己到Ethereum API | IPFS API &amp; Gateway | ETH Nodes as a Service | Infura 注册一个，使用自己注册的节点来减少拥堵。 1## enable swap (default true)swap-enable: true## swap ethereum blockchain endpoint (default \"http://localhost:8545\")swap-endpoint: https://rpc.slock.it/goerli 其它配置请参考配置文件 – MoDocs (lovpia.com)。 启动运行Bee更新完配置文件以后，可以直接通过命令行启动来检测配置是否正确。第一次启动会需要输入密码，同时需要账户有至少10gBZZ作为启动资金。 领取启动资金先通过bee-clef-keys命令获取节点的ethernum地址（在产生的bee-clef-jey-xxxx.json文件中address字段）。 faucet-request (discord.com) - 通过faucet机器人领取，是好是坏，碰运气。 Goerli: Authenticated Faucet (mudit.blog) 需要先在Twitter上发布条信息，然后把twitter链接粘贴到页面里领取，可以一次领取37.5gETH，然后到Bzzaar (ethswarm.org)兑换即可，成功率很高，而且可以兑换不止10个gBZZ. 运行Bee可以直接执行bee start来启动，然后查看运行日志是否正常。如果使用自定义配置文件，就加上--config &lt;path to bee.yaml&gt;。 Bee正常启动以后，会默认监听:1633端口，当日志中出现api address: xxxx时，Bee已经启动。如果打开了debug api，也会在日志中看到debug api address: xxx:1633. 1# bee start --config bee.yaml Welcome to the Swarm.... Bzzz Bzzzz Bzzzz \\ / \\ o ^ o / \\ ( ) / ____________(%%%%%%%)____________ ( / / )%%%%%%%( \\ \\ ) (___/___/__/ \\__\\___\\___) ( / /(%%%%%%%)\\ \\ ) (__/___/ (%%%%%%%) \\___\\__) /( )\\ / (%%%%%) \\ (%%%) ! INFO[2021-05-18T13:55:09+08:00] version: 0.5.3-acbd0e2 INFO[2021-05-18T13:55:09+08:00] using swarm network address through clef: &lt;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&gt; INFO[2021-05-18T13:55:09+08:00] swarm public key &lt;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&gt; INFO[2021-05-18T13:55:09+08:00] pss public key &lt;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&gt; INFO[2021-05-18T13:55:09+08:00] using ethereum address &lt;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&gt;INFO[2021-05-18T13:55:09+08:00] debug api address: 127.0.0.1:1635 INFO[2021-05-18T13:55:11+08:00] using default factory address for chain id 5: &lt;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&gt; INFO[2021-05-18T13:55:12+08:00] using existing chequebook &lt;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&gt; INFO[2021-05-18T13:55:25+08:00] database capacity: 2000000 chunks (approximately 7.8GB) INFO[2021-05-18T13:55:33+08:00] name resolver: no name resolution service provided INFO[2021-05-18T13:55:33+08:00] api address: [::]:1633...# 注意：其中的xxx为你的Bee节点对应的key和地址信息. 确保Bee可以正常启动并运行以后，就可以把Bee加入到系统服务后台运行就可以了。 查看Bee基本信息最基本的就是在浏览器直接查看localhost:1633, 也可以在命令行用curl命令查看，如果显示Ethereum Swarm Bee就说明已经在运行了。 1# curl -s localhost:1633Ethereum Swarm Bee 其它信息可以通过[bee debug api](Bee Debug API (ethswarm.org))查看。 比如自己做一个简单的bee_health_check.sh脚本，可以快速输出当前Bee节点的基本信息。 1#!/usr/bin/env bash# get addresses of current nodeecho '====&gt; 获取Bee节点地址...'echo '&gt; curl -s localhost:1635/addresses'curl -s localhost:1635/addresses | jq# check connected peersecho '====&gt; 获取已经建立连接的节点列表...'echo '&gt; curl -s localhost:1635/peers'curl -s localhost:1635/peers | jq# check balance# echo '====&gt; 获取账户基本信息...'# echo 'curl -s localhost:1635/balances'# curl -s localhost:1635/balances | jq# get chequebook balanceecho '====&gt; 获取支票账户信息...'echo '&gt; curl -s localhost:1635/chequebook/balance'curl -s localhost:1635/chequebook/balance | jqecho '====&gt; 获取支票信息...'echo '&gt; curl -s localhost:1635/chequebook/cheque'curl -s localhost:1635/chequebook/cheque | jq 另外一种方式是直接使用bee-dashboard查看，就是把bee debug api获取的状态通过图形界面可视化。需要提前打开debug api，具体参考[bee-dashboard教程](ethersphere/bee-dashboard: An app which helps users to setup their Bee node and do actions like cash out cheques (github.com))。 2. 其它注意事项问题1：could not connect to backend at xxx1could not connect to backend at https://rpc.slock.it/goerli. In a swap-enabled network a working blockchain node (for goerli network in production) is required. Check your node or specify another node using --swap-endpoint. Error: get chain id: Post \"https://rpc.slock.it/goerli\": dial tcp 185.20.210.132:443: i/o timeout 因为Swap节点不可用，或者节点拥堵，建议到Ethereum API | IPFS API &amp; Gateway | ETH Nodes as a Service | Infura 注册一个自己的节点，避免官方节点拥堵。","link":"/2021/05/27/Swarm/Install-Bee-under-Ubuntu/"},{"title":"Swarm Bee配置","text":"每个Bee节点可以在启动的时候添加命令行参数来配置，具体参数可以通过bee start --help查看。 例如下边这个例子，我们打开了Bee的debug API，并且设置debug API的监听端口为6666. 1234bee start \\ --api-addr=:8888 \\ --debug-api-enable=true \\ --debug-api-addr=:6666 配置文件Bee节点也可以通过提供--config加yaml配置文件的方式来配置。 1bee start --config /home/&lt;user&gt;/bee-config.yaml 提示： 可以通过命令bee printconfig &amp;&gt; bee-default.yaml导出当前配置文件作为默认修改版本。 配置通过软件包管理器安装的Bee如果你的Bee是通过apt-get或yum这样的软件包管理器安装的，在安装过程中会自动生成一个配置文件，Bee启动的时候默认使用这个配置文件。 要修改Bee配置，可以直接修改对应的配置文件，然后重启Bee生效。 Linux 12sudo vi /etc/bee/bee.yamlsudo systemctl restart bee Mac OS 12vi /usr/local/etc/swarm-bee/bee.yamlbrew services restart swarm-bee 自动产生配置文件通过命令行启动Bee时候，用printconfig替换start可以很简单的生成Bee的配置文件。 例子 123bee printconfig \\ --verbosity=5 \\ &amp;&gt; bee-config.yaml 上述命令会生成类似下边的文件内容，其中包含了Bee的默认配置。 配置选项全局选项–config设置Bee配置文件，默认为/home/&lt;user&gt;/.bee.yaml. 启动选项–api-addr默认 :1633. Bee API地址和端口。忽略IP地址，会监听所有地址的对应端口。 –bootnode默认/dnsaddr/bootnode.ethswarm.org. 设置Bee启动节点的地址（要启动或加入的网络），可以是多个地址。 默认情况下节点会连接到Swarm主网。如果要使用私有或者测试网络，必须配置启动节点。 –clef-signer-enable默认false. 如果要使用以太坊的Clef作为独立的交易签名器，设置为true。 Clef是以太坊的新功能，需要相应的规则文件或者运行在高级模式下，用来实现对交易和支票的自动签名。 –clef-signer-endpoint默认为当前操作系统下clef的默认路径。 你也可以为你的Clef签名器指定自定义ipc文件。 –clef-signer-ethernum-address默认会选择clef下的第一个地址（index 0）。 如果你在Bee Clef中导入了多个key，可以使用这个参数来指定要使用的地址。 注意：如果在Bee Clef中导入了多个地址，必须为每个Bee节点指定对应的签名器地址，第一个地址也需要配置，因为这些地址在导入的时候可能会重新排序。 –cors-allowed-origins默认为[]. 允许的Http/WS API响应地址域。API只会接受对应地址域的请求，例如： 12bee start --cors-allowed-origins=\"*\"bee start --cors-allowed-origins=\"https://website.ethswarm.org\" –data-dir默认/home/&lt;user&gt;/.bee. Bee数据存储路径。包含以下三种类型的数据。 区块数据 具体会包含本地pin过的区块数据和文件、缓存的区块数据、或当前节点职责范围内需要提供给对端节点的区块数据。 状态数据 本地Bee节点的状态数据，需要备份。 密钥库（keystore）数据 包含加密过的私钥，需要备份并且保证私密性。 注意：在秘钥库(keystore)中的文件要保证绝对的安全！它们是你的网络身份的加密标记，一旦丢失无法恢复。 –db-capacity默认5000000. 区块数据容量。区块数据已4086byte作为基础单位，所以总的数据库容量（kb）大概为db-capacity * 4096. 默认值5,000,000个区块大概有20.5gb。为了能够在网络中有效工作，我们建议一个Bee节点的容量至少要2.5gb。一些不参与数据存储的节点可以设置更小的容量。 下边4个参数对应更低层级的配置，是针对LevelDB的Openfile函数的配置。 –db-block-cache-capacity默认33554432。 对应LevelDB的BlcokCacheCapacity. –db-disable-seeks-compaction默认false. 对应LevelDB的DisableSeeksCompaction. –db-open-files-limit默认200. 注意：为了兼容低性能的硬件和操作系统，--db-open-files-limit的默认值设置的比较低。建议如果可能的话，增大到接近10000或者更多。 对应LevelDB的OpenFileCacheCapacity. –db-write-buffer-size默认33554432. 对应LevelDB的WriteBuffer. –debug-api-addr默认:1635. Debug API的地址和端口。忽略地址会监听主机的所有接口。 --debug-api-enable必须设置才会生效。 –debug-api-enable默认false. 设置为true来打开debug api。 –gateway-mode默认false. 设置为true会关闭API中的一些敏感功能，可以使api地址在公共网络中更安全。 –global-pinning-enable默认false. 设置为true来打开全局pin功能。 –nat-addr默认\"\". 设置对应的NAT公网IP。一般情况下会自动生成，一些特殊情况可能需要手工设置。 –network-id默认1. 接受新连接的网络ID。主网设置1, 测试网2. –p2p-addr默认:1634. p2p协议消息的IP地址和端口。 –p2p-quic-enable默认false. –p2p-ws-enable默认false. 配置是否打开p2p通信的web-socket传输。 –password默认\"\". 解密Swarm标识密钥的密码。 注意：在命令行中设置密码是不安全的。在生成环境中请使用密码文件或环境变量。 –password-file默认\"\". 指向解密用的密码文件路径。空字符串密码不需要设置。 –payment-early默认 1000000000000. 触发Bee结算的最低结算限制。 –payment-threshold默认 10000000000000. 从对等节点获得付款的最低支付门限，超过这个值才会触发支付。 –payment-tolerance默认 50000000000000 可容忍的最大欠债，超过这个门限后Bee会从这个节点断开。 –resolver-options默认 eth:0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e@localhost:8545. –standalone默认 false 如果不想让Bee节点连接网络，设置true. 开发模式下使用。 –swap-enable默认 true –swap-endpoint默认 http://localhost:8545 以太坊区块链交换节点。 –swap-factory-address默认 anointed contract for the current blockchain id –swap-initial-deposit默认 100000000000000000 –tracing-enable默认 false –tracing-endpoint默认 127.0.0.1:6831 –tracing-service-name默认 bee –verbosity默认 info Bee日志等级：0=silent, 1=error, 2=warn, 3=info, 4=debug, 5=trace –welcome-message默认 \"\" 连接到对端节点时显示的欢迎信息。 环境变量可以使用环境变量定义Bee的配置。 在环境变量中定义好对应的值以后，直接在命令行参数中使用。 例如：bee start --api-addr $VARIABLE_NAME。 配置优先级Bee配置按照以下优先级（从高到低）加载处理，高优先级中的配置会覆盖低优先级中的值。 命令行参数 环境变量 配置文件","link":"/2021/05/27/Swarm/Swarm-Bee-Configuration/"}],"tags":[{"name":"expo","slug":"expo","link":"/tags/expo/"},{"name":"assets","slug":"assets","link":"/tags/assets/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Context","slug":"Context","link":"/tags/Context/"},{"name":"Swarm","slug":"Swarm","link":"/tags/Swarm/"},{"name":"Bee","slug":"Bee","link":"/tags/Bee/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"BZZ","slug":"BZZ","link":"/tags/BZZ/"}],"categories":[]}